# О QT

Qt — кроссплатформенный фреймворк для разработки программного обеспечения на языке программирования C++. 

Qt Creator (ранее известная под кодовым названием Greenhouse) — кроссплатформенная свободная IDE для разработки на С, С++ и QML. Разработана Trolltech (Digia) для работы с фреймворком Qt.

**Задание 1:** *Запустите Qt Creator. Создайте проект Приложение -> Qt Widgets Application. Название для класса главного окна оставьте без изменения. Откройте форму mainwindow.ui. Добавьте на неё три Label в одну колонку и справа от них три LineEdit. Поменяйте надписи в Label на "Проект", "Название проекта" и "Город". Поменяйте названия для текстовых полей на JEdit, JNameEdit, JTownEdit. Добавьте под ними кнопку с текстом "Поставщики..." и названием SuppliersButton. Проверьте работу приложения.*

# Сигналы и слоты

Сигналы и слоты — подход, используемый в некоторых языках программирования и библиотеках (например, Boost и Qt). Концепция заключается в том, что компонент (часто виджет) может посылать сигналы, содержащие информацию о событии (например: был выделен текст «слово», была открыта вторая вкладка). В свою очередь другие компоненты могут принимать эти сигналы посредством специальных функций — слотов.

Сигналы объявляются внутри класса в разделе "signal:". Слоты описываются в разделах "public|protected|private slots:" и представляют из себя методы класса. Например, рассмотрим класс, содержащий одно число, которое может быть изменено при вызове setValue. В заголовочном файле counter.h класс описан следующим образом:

```C++
#include <QObject>
class Counter : public QObject
{
   Q_OBJECT
public:
   Counter() { m_value = 0; }
   int value() const { return m_value; }
public slots:
   void setValue(int value);
signals:
   void valueChanged(int newValue);
private:
   int m_value;
};
```


Реализацию метода setValue(int) поместим в counter.cpp:

```C++
#include "counter.h"
void Counter::setValue(int value)
{
   if (value != m_value) {
     m_value = value;
     emit valueChanged(value);
   }
}
```
    
Ключевое слово emit вырабатывает сигнал valueChanged() объекта с новым значением в качестве аргумента.

Для связи сигнала и слога используется функция статическая функцию QObject::connect():

```C++
Counter a, b;
QObject::connect(&a, SIGNAL(valueChanged(int)),
        &b, SLOT(setValue(int)));
a.setValue(12);   // a.value() == 12, b.value() == 12
b.setValue(48);   // a.value() == 12, b.value() == 48
```

Все объекты в Qt Creator, размещаемые на форме, при настройках по умолчанию помещаются внутри указателя на объект ui.

Также, при работе с Qt Creator сигналы и слоты объектов диалога можно связывать в графическом режиме. Для этого при редактировании формы перейдите в режим редактирования слотов/сигналов с помощью кнопки на панели над формой, или с помощью горячей клавиши. Чтобы соединить сигнал одного объекта со слотом другого, зажмите мышь над первым и перенесите на второй. Чтобы добавить связь с диалогом, выберите область, где не находится ни один другой виджет. Выберите в открывшемся окне какой сигнал с каким слотом связать. Если подходящих сигналов и слотов нет, вы можете их добавить. Однако, при компиляции они должны быть описаны в соответствующих классах. В случае их отсутствия при запуске программы будет выведено предупреждение.

**Задание 2:** *Добавьте главному окну слот showSuppliers() в файле mainwindow.h. Реализацию разместите в mainwindow.cpp . Соедините сигнал кнопки ProvidersButton со слотом showSuppliers(). Сделайте так, чтобы при нажатии на кнопку отображалось какое-нибудь сообщение с помощью QMessageBox, воспользовавшись его статической функцией information. Проверьте работу приложения.*

# Диалоги

Диалоги предоставляют пользователям возможность что-то изменить, что-то задать, в соответствии с их предпочтениями. В большинстве своем, программы с графическим интерфейсом имеют главное окно, с полосой меню и панелью инструментов, и множество диалоговых окон, каждое из которых предназначено для обмена информацией с пользователем или вывода ее в определенном формате. Зачастую приложение может быть оформлено как одно диалоговое окно, которое напрямую взаимодействует с пользователем, получая от него команды и выполняя соответствующие им действия. Такие приложения называются диалоговыми приложениями. Примером диалогового приложения может служить программа-калькулятор.

Для добавления нового диалога нужно нажать правой кнопкой на проект и выбрать Add new... Или File->New File or Project... . В открывшемся окне выберите Files and Classes: Qt -> Qt Designer Form Class . Таким образом будет создана форма для диалога, а также заголовочный файл и файл исходного кода для класса, соответствующего диалогу.

Одним из вариантов вызова диалога является создание представителя класса соответствующего этому диалогу и вызов метода exec() у него. Метод exec() унаследован от QDialog и возвращает результат его выполнения: Rejected (0) или Accepted (1) - в зависимости от того, был вызван у диалога метод accept() или reject().

Например, если класс созданного диалога называется Dialog, то его вызов осуществляется 

По умолчанию, для диалогов с кнопками сигнал при нажатии на Cancel связан с reject(), а OK - с accept(). Также диалог будет закрыт при нажатии Enter или Escape.

Более подробно об использовании диалогов смотрите в [[4]](http://www.opennet.ru/docs/RUS/qt3_prog/c345.html).

Менеджер размещения (layout manager) - это объект, который управляет размерами и положением виджетов. Qt предоставляет в наше распоряжение следующие менеджера размещения: QHBoxLayout выравнивает виджеты по горизонтали, QVBoxLayout -- по вертикали, QGridLayouts - по сетке и др. Менеджеры размещения (или, если хотите, менеджеры компоновки) могут содержать как отдельные виджеты, так и другие менеджеры размещения. Вкладывая друг в друга QHBoxLayout, QVBoxLayout и QGridLayouts, в различных комбинациях, можно выстроить весьма замысловатый интерфейс диалога. Изменение размеров Layout'ов повлечёт соответствующие изменения размеров объектов внутри них. Если для окна задать layout manager, то при изменении его размеров виджеты будут подстраиваться соответствующим образом.

Поменять Layout для окна в QtCreator можно с помощью кнопок на панели над окном, а также нажав правой кнопкой на диалог в Object Inspector в правом верхнем углу.

**Задание 3:** *Добавьте новый диалог в проект, на форме разместите TableView. Установите для диалога вертикальное расположение объектов (Lay out vertically). Сделайте так, чтобы при нажатии на кнопку SuppliersButton открывался данный диалог. Проверьте работу приложения. Убедитесь, что при изменнеии размеров, автоматически увеличиваются размеры TableView.*

# SQL

Чтобы подключить к проекту модуль sql необходимо открыть файл проекта (.pro файл) и дописать в конце строки " QT += " sql.

Для того, чтобы использовать классы, связанные с SQL, мужно или подключать их поотдельности, подключая соответствующие заголовочные файлы, или все вместе, подключив заголовочный файл QtSql.

Чтобы получить доступ к базе данных с помощью QSqlQuery и QSqlQueryModel, необходимо создать и открыть одно или более соединений с базой данных. Соединиться с базой данных можно вот так:

```C++
QSqlDatabase db = QsqlDatabase::addDatabase("QMYSQL");
db.setHostName("HostName");
db.setDatabaseName("DataBaseName");
db.setUserName("UserName");
db.setPassword("Password");
bool ok = db.open();
```

Первая строка создает объект соединения, а последняя открывает его. В промежутке инициализируется некоторая информация о соединении, включая имя узла, имя базы данных, имя пользователя, пароль. Аргумент «QMYSQL» в addDatabase() указывает тип драйвера базы данных. Если open() потерпит неудачу, он вернет false. В этом случае, можно получить информацию об ошибке, вызвав QSqlDatabase::lastError().

Класс QSqlQuery обеспечивает интерфейс для выполнения SQL запросов и навигации по результирующей выборке.
Для выполнения SQL запросов, просто создают объект QSqlQuery и вызывают QSqlQuery::exec(). Если возникает ошибка, exec() возвращает false. Доступ к ошибке можно получить с помощью QSqlQuery::lastError().

После вызова exec(), внутренний указатель QSqlQuery указывает на позицию перед первой записью. Если вызвать метод QSqlQuery::next() один раз, то он переместит указатель к первой записи. После этого необходимо повторять вызов next(), чтобы получать доступ к другим записям, до тех пор пока он не вернет false. Вот типичный цикл, перебирающий все записи по порядку:

```C++
while (query.next()) {
  QString name = query.value(0).toString();
  int salary = query.value(1).toInt();
  qDebug() << name << salary;
}
```

QSqlQuery может выполнять не только SELECT, но также и любые другие запросы.

Подробнее о QSqlQuery смотрите в [[6]](http://doc.qt.io/qt-5/qsqlquery.html).

**Задание 4:** *Добавьте в список используемых модулей sql. В файле main.cpp подключитесь к базе. В случае, если происходит ошибка подключения, выведите сообщение об ошибке. Проверьте работу приложения.*

# Модели

Классы QSqlQueryModel, QSqlTableModel и QSqlRelationalTableModel могут использоваться в качестве источников данных для классов представлений Qt, таких как QListView, QTableView и QTreeView. 

QSqlQueryModel предоставляет модель, доступную только для чтения, основанную на SQL запросе.

QSqlTableModel представляет из себя модель с доступок к SQL таблице на чтение и запись. 

Для того, чтобы отобразить данные модели в таблице, необходимо использовать метод setModel у QTableView. Указатель на саму модель можно хранить в классе окна и создавать в конструкторе. Удалять модель в деструкторе нет необходимости, поскольку она будет удалена при вызове деструктора QTableView.

**Задание 5:** *Добавьте в класс Dialog поле model, имеющее тип QSqlTableModel\* . В конструкторе создайте новую модель и сохраните в model. Используя соответствующий метод задайте для модели таблицу S, а для ui->tableView диалога - модель model. Добавьте в деструктор удаление модели model. Проверьте работу приложения.*

При помощи QDataWidgetMapper можно связывать элементы окна (например, текстовые поля) с полями моделей. При этом любые изменения, внесенные в них будут внесены и в модель после окончания ввода и переключения на другое объект или вручную в зависимости от настроек.

Для работы с QDataWidgetMapper необходимо установить модель, откуда брать данные, с помощью setModel(model). Чтобы подключить к QDataWidgetMapper объект, необходимо использовать метод addMapping. В качестве первого параметра указывается объект, а в качестве второго - номер столбца, которому он должен соответствовать. Номер столбца можно получить при помощи метода модели fieldIndex.

Пример использования QDataWidgetMapper смотрите в [[8]](http://doc.qt.io/qt-5/qtsql-sqlwidgetmapper-example.html)

**Задание 6:** *Добавьте в класс MainWindow модель QSqlTableModel\*, а также объект mapper типа QDataWidgetMapper\* . Добавьте на форму MainWindow две кнопки "Назад" и "Вперед". В конструкторе создайте модель, задайте ей таблицу J. Для mapper задайте модель model, а также свяжите поля "J", "Имя" и "Город" с JEdit, JNameEdit, JTownEdit.  Свяжите внутри конструктора сигналы clicked(bool) кнопок Вперед и Назад со слотами mapper toNext() и toPrevious() соответственно. После этого выполните метод toFirst(), чтобы отобразить заполнить текстовые поля первой строкой таблицы.*

**Задание 7:** *Модифицируйте программу так, чтобы при нажатии на кнопку поставщики выводилась информация о поставщиках для данного проекта. Предполагаемая последовательность действий:
Измените в классе Dialog тип модели на QSqlQueryModel\* . В конструктор добавьте в качестве параметра строку с кодом проекта. Внесите соответствующие изменения в конструктор. Замените использование setTable на setQuery. В качестве параметра передайте запрос, результаты которого вы хотите отобразить (допустим, что код проекта в передан в качестве параметра QString prj): "SELECT S.ИМЯ Поставщик, S.Город FROM S JOIN SPJ ON S.П=SPJ.П WHERE SPJ.J='" + prj + "';" . Проверьте работу программы. Измените запрос, чтобы для каждого поставщика выводились детали, которые он поставляет проекту.*

# Список использованных источников:

1. http://ru.wikipedia.org
2. https://habrahabr.ru/post/50812/
3. http://www.opennet.ru/docs/RUS/qt3_prog/c345.html
4. http://www.opennet.ru/docs/RUS/qt3_prog/x1707.html
5. https://habrahabr.ru/post/51650/
6. http://doc.qt.io/qt-5/qsqlquery.html
7. http://doc.qt.io/qt-5/sql-model.html
8. http://doc.qt.io/qt-5/qtsql-sqlwidgetmapper-example.html
